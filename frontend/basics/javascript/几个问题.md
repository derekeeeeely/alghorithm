- 深浅拷贝

    ```jsx
    isPrimitive = (s) => Object.prototype.toString.call(s) !== '[object Object]'

    // 浅拷贝 引用赋值，传递的地址
    Object.assign(target, source1, source2) // 复制可枚举属性 primitive+reference
    // Object.entries 返回顺序和for in一致，但前者只返回自身可枚举，后者还返回原型链可枚举
    function copy(source) {
    	if (isPrimitive(source)) { return source }
    	let res = Object.create(null);
    	Object.entries(source).map((k, v) => {
    		res[k] = v;
    	})
    	return res;
    }

    // 深拷贝 拷贝的值为对象时 递归至primitive
    function copy(source) {
    	if (isPrimitive(source)) { return source }
    	let res = Object.create(null);
    	Object.entries(source).map((k, v) => {
    		if (isPrimitive(v)) {
    			res[k] = v;
    		} else {
    			res[k] = copy(v);
    		}
    	})
    	return res;
    }

    // 循环引用
    function dcopy(s) {
    	const root = {};
    	const uniqueList = new WeakMap();
    	const list = [{ parent: root, key: undefined, data: s }];
    	while(list.length) {
    		const node = list.pop();
    		const { parent, key, data } = node;
    		if (uniqueList.has(data)) {
    			parent[key] = data;
    			break;
    		}
    		let res = parent;
    		if (typeof key !== 'undefined') {
    			res = parent[key] = {}
    		}
    		Object.entries(source).map((k, v) => {
    			if (isPrimitive(v)) {
    				res[k] = v;
    			} else {
    				list.push({ parent: res, key: k, data: v })
    			}
    		})
    		uniqueList.set(data, res);
    	}
    	return root;
    }
    ```

- 节流防抖

    ```jsx
    // 节流 一定时间内只执行一次，后续触发的如果在限定冷却时间内 则不执行
    const throttle = (fn, time) => {
    	let previous = Date.now();
    	return (...args) => {
    		let now = Date.now();
    		if (now - previous >= time) {
    			fn.apply(this, args)
    		}
    	}
    }

    // 防抖 限定时间内如果后续触发了，则设置新的定时器
    const debounce = (fn, time) => {
    	let timer;
    	return (...args) => {
    		if (timer) {
    			clearTimeout(timer)
    		}
    		timer = setTimeout(() => {
    			fn.apply(this, args)
    		}, time)
    	}
    }
    ```

- curry

    ```jsx
    function curry(fn, m) {
    	return function() {
    		fn.call(this, m, arguments)
    	}
    }
    ```